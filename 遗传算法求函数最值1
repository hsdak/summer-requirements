遗传算法求函数最值1
//Rosenbrock函数的全局最大值计算
//max f(x1,x2)=100(x1^2-x2^2)^2+(1-x1)^2
//s.t. -2.048<=xi<=2.048(xi=1,2)
分析：
本题的基因组较为简单，选择由两个2位2进制数组成的4位2进制数编码作为基因序列，并通过在常规基础上简化过的步骤进行运算。
实际解决问题时，这样做的确麻烦了，但重在算法的学习。
c++code:
#include<iostream>
#include<ctime>
#include<cstdlib>
#include<vector>
using namespace std;
//初始群体的产生
void chushi(vector<vector<int> >&a){
	int i,j;
	for(i=0;i<4;i++){//随机构建基因组
		for(j=0;j<4;j+=2){
			srand(time(0));
			if(rand()%1000>500){
				a[i][j]=0;
				a[i][j+1]=1;
			}
			else{
				a[i][j]=1;
				a[i][j+1]=0;
			}
		}
	}
}
//适应度计算
int shiying(int a,int b,int c,int d){
	int f,x1,x2;
	x1=a*2+b;
	x2=c*2+d;
	f=100*(x1*x1-x2*x2)*(x1*x1-x2*x2)+(1-x1)*(1-x1);//目标函数的值作为适应度
	return f;
}
//选择运算
void xuanze(vector<vector<int> >&a){
	vector<vector<int> > b;
	int i,r;
	b=a;
	for(i=0;i<4;i++){//选出表现型适应度较高的个体形成种群
		srand(time(0));
		r=rand()%(a[0][4]+a[1][4]+a[2][4]+a[3][4]);
		if(r<a[0][4]){
			b[i]=a[0];
		}
		else if(r<a[1][4]){
			b[i]=a[1];
		}
		else if(r<a[2][4]){
			b[i]=a[2];
		}
		else if(r<a[3][4]){
			b[i]=a[3];
		}
		a=b;
	}
}
//交叉运算
void jiaocha(vector<vector<int> >&a){
	int r1,r2,t,i;
	bool flag[4]={false};//记录个体的状态：基因是否已参与重组
	srand(time(0));
	r1=rand()%4;//随机配对
	flag[r1]=true;
	while(r2!=r1){
		srand(time(0));
		r2=rand()%4;//随机配对
	}
	flag[r2]=true;
	t=a[r1][0];
	a[r1][0]=a[r2][0];
	a[r2][0]=t;
	t=a[r1][1];
	a[r1][1]=a[r2][1];
	a[r2][1]=t;
	for(i=0;i<4;i++){
		if(!flag[i]){
			r1=i;
		}
	}
	for(;i<4;i++){
		if(!flag[i]){
			r2=i;
		}
	}
	t=a[r1][0];
	a[r1][0]=a[r2][0];
	a[r2][0]=t;
	t=a[r1][1];
	a[r1][1]=a[r2][1];
	a[r2][1]=t;
}
//变异运算
void bianyi(vector<vector<int> >&a){
	int i,r1,r2;
	for(i=0;i<4;i++){
		srand(time(0));
		r1=rand()%1000;//随机获取发生变异的基因座
		if(r1>500){
			srand(time(0));
			r2=rand()%1000;//假设千分之一的概率发生变异
			if(r2==0){
				if(a[i][0]==0){
				a[i][0]=1;
				a[i][1]=0;
				}
			}
			else{
				a[i][0]=0;
				a[i][1]=1;
			}
		}
		else{
			srand(time(0));
			r2=rand()%1000;
			if(r2==0){
				if(a[i][2]==0){
				a[i][2]=1;
				a[i][3]=0;
				}
			}
			else{
				a[i][2]=0;
				a[i][3]=1;
			}
		}
	}
}
//主函数
int main(){
	vector<vector<int> > a(4,vector<int>(5));
	int i,j,max;
        chushi(a);//初始种群的产生
	for(i=0;i<5;i++){//培养五代
		for(j=0;j<4;j++){
			a[j][4]=shiying(a[j][0],a[j][1],a[j][2],a[j][3]);
		}
		xuanze(a);//选择运算
		jiaocha(a);//交叉运算
		bianyi(a);//变异运算
	}
	max=a[0][4];
	for(i=1;i<4;i++){//选出当代种群最高适应度
		if(max<a[i][4]){
			max=a[i][4];
		}
	}
	cout<<"max="<<max<<endl;//输出适应度，即函数最大值
	return 0;
}
