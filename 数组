一维数组和二维数组
第一题
加一
给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
c++代码：
vector<int> plusOne(vector<int>& digits) {
        int num=1;
        for(int i=digits.size()-1;i>=0;i--){
            num+=digits[i];
            digits[i]=num%10;
            num/=10;
            if(!num){
                break;
            }
        }
        if(num==1){
            digits.resize(digits.size()+1,0);
            digits[0]=1;
        }
        return digits;
    }
第二题
删除排序数组中的重复项
给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
c++代码：
int removeDuplicates(vector<int>& nums) {
        int size=nums.size();
        int count=0;
        for(int i=1;i<size;++i){//查找重复项
            if(nums[i]==nums[i-1]){//对比两项
                count++;//记录重复项数
            }
            nums[i-count]=nums[i];//删除重复项
        }
        return size-count;//返回新长度
    }
第三题
盛水最多的容器
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，
垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
说明：你不能倾斜容器，且 n 的值至少为 2。
c++代码：
int maxArea(vector<int>& height) {
        int i,j,v0=0,v;//v0为目前最大盛水量，v计算任意两端之间盛水量
        for(i=0;i<height.size();i++){
            for(j=i+1;j<height.size();j++){//以矮的一端为高
                if(height[i]<height[j]){
                    v=(j-i)*height[i];
                }
                if(height[i]>height[j]){
                    v=(j-i)*height[j];
                }
            }
            if(v>v0){
                v0=v;//更新最大盛水量
            }
        }
        return v0;
    }
第四题
给你一个整数数组 nums，每次 操作 会从中选择一个元素并 将该元素的值减少 1。
如果符合下列情况之一，则数组 A 就是 锯齿数组：
	每个偶数索引对应的元素都大于相邻的元素，即 A[0] > A[1] < A[2] > A[3] < A[4] > ...
	或者，每个奇数索引对应的元素都大于相邻的元素，即 A[0] < A[1] > A[2] < A[3] > A[4] < ...
返回将数组 nums 转换为锯齿数组所需的最小操作次数。
c++代码：
int movesToMakeZigzag(vector<int>& nums) {
        int i,count1=0,count2=0;
        i=1;
        while(i<nums.size()){//偶数索引的情况
            if(nums[i]>nums[i-1]){
                count1++;
                continue;
            }
            if(nums[i]>nums[i+1]){
                count1++;
                continue;
            }
            i+=2;
        }
        i=0;
        while(i<nums.size()){//奇数索引的情况
            if(i=0){
                if(nums[i]>nums[i+1]){
                    count2++;
                    continue;
                }
            }
            else{
                if(nums[i]>nums[i-1]){
                    count2++;
                    continue;
                }
                if(nums[i]>nums[i+1]){
                    count2++;
                    continue;
                }
            }
        }
        //比较哪种更短并输出
        if(count1>=count2){
            return count2;
        }
        else{
            return count1;
        }
    }
第五题
合并两个有序数组
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
说明:
	初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
	你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
c++代码：
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for(int n:nums2){//将nums2的元素加到nums1最后一个元素的后面
            nums1[m++]=n;
        }
        sort(nums1.begin(),nums1.end());//对整合后的数组进行排序
    }
第六题
和为k的子数组
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
说明 :
	数组的长度为 [1, 20,000]。
	数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。
c++代码：
int subarraySum(vector<int>& nums, int k) {
        int i,j,count=0,a;
        for(i=0;i<nums.size();i++){
            a=nums[i];
            for(j=i;j<nums.size();j++){
                if(a==k){//合为k则计数加一
                    count++;
                }
                a+=nums[j];
                if(a>k){//若子数组的和超过k则进入下一个循环
                    break;
                }
            }
        }
        return count;
    }
第七题：
将每个元素替换为右侧最大元素
给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。
完成所有替换操作后，请你返回这个数组。
示例：
输入：arr = [17,18,5,4,6,1]
输出：[18,6,6,6,1,-1]
提示：
	1 <= arr.length <= 10^4
	1 <= arr[i] <= 10^5
c++代码：
vector<int> replaceElements(vector<int>& arr) {
        int i,j,max;
        for(i=0;i<arr.size();i++){
            max=arr[i+1];
            for(j=i+2;j<arr.size();j++){
                if(arr[j]>max){
                    max=arr[j];//寻找右侧最大元素
                }
            }
            arr[i]=max;//替换
        }
        arr[arr.size()-1]=-1;
        return arr;
    }
第八题
去掉最低工资和最高工资后的平均工资
给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。
请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。
c++代码：
double average(vector<int>& salary) {
        int i,max=0,min=0,a=0;
        for(i=1;i<salary.size();i++){
            if(salary[i]>salary[max]){//选出最高工资下标
                max=i;
            }
            if(salary[i]<salary[min]){//选出最低工资下标
                min=i;
            }
        }
        for(i=0;i<salary.size();i++){
            if(i!=max&&i!=min){
                a+=salary[i];
            }
        }
        return a/(salary.size()-2);//返回平均值
    }
第九题
探索插入位置
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
c++代码：
int searchInsert(vector<int>& nums, int target) {
        int i;
        for(i=0;i<nums.size();i++){
            if(target<=nums[i]){
                return i;
            }
        }
        return i;
    }
 第十题
 统计有序数列中的负数
 给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 
请你统计并返回 grid 中 负数 的数目。
 c++代码：
int countNegatives(vector<vector<int>>& grid) {
        int count = 0;
        for(int i = 0;i<grid.size();i++){//遍历查找
            for(int j= 0;j<col = grid[0].size();j++){
                if(grid[i][j]<0)
                    count++;
            }
        }
        return count;
    }
给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。
c++代码：
int trap(vector<int>& height) {
        int ans=0,j;
        for(int i=1;i<height.size()-1;i++){
            int max1=height[i],max2=height[i];
            for(j=i-1;j>=0;j--){
                if(height[j]>height[i]){
                    max1=height[j];
                }
            }
            for(j=i+1;j<height.size();j++){
                if(height[j>height[i]]){
                    max2=height[j];
                }
            }
            if(max1>=max2){
                ans+=max1-height[i];
            }
            else{
                ans+=max2-height[i];
            }
        }
        return ans;
    }
