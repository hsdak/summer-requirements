第一题
给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。
换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。示
例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。
思路：双指针分别从两链表头结点每步一个链节走到尾结点，再从另一个头结点走到交点，经过的链节数量相同。
c++代码：
 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *t1 = headA; ListNode *t2 = headB;
        while(t1 != t2){
            if (t1 == NULL)
                t1 = headB;
            else t1 = t1->next;
            if (t2 == NULL)
                t2 = headA;
            else t2 = t2->next;
        }
        return t1;
    }
第二题：
返回倒数第K个节点
实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。
注意：本题相对原题稍作改动
示例：
输入： 1->2->3->4->5 和 k = 2
输出： 4
说明：
给定的 k 保证是有效的。
思路：先将前指针与后指针的距离固定好，之后同步前进，直到前指针走到结尾为止。
c++代码：
int kthToLast(ListNode* head, int k) {
        ListNode *p1=head,*p2=head;
        if(head==NULL){
            return 0;
        }
        while(k--){
            p2=p2->next;
        }
        while(p2!=NULL){
            p2=p2->next;
            p1=p1->next;
        }
        return p1->val;
    }
第三题
删除中间节点
实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。
示例：
输入：单向链表a->b->c->d->e->f中的节点c
结果：不返回任何数据，但该链表变为a->b->d->e->f
思路：这只是一个玩笑罢了，其实解决不了实际问题。
c++代码：
void deleteNode(ListNode* node) {
        node->val = node->next->val;
        node->next = node->next->next;
    }
第四题
